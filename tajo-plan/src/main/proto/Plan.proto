/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

option java_package = "org.apache.tajo.plan.serder";
option java_outer_classname = "PlanProto";
option java_generic_services = false;
option java_generate_equals_and_hash = true;

import "PrimitiveProtos.proto";
import "CatalogProtos.proto";
import "DataTypes.proto";

enum NodeType {
  SET_SESSION = 0;

  ROOT = 1;
  EXPRS = 2;
  PROJECTION = 3;
  LIMIT = 4;
  WINDOW_AGG = 5;
  SORT = 6;
  HAVING = 7;
  GROUP_BY = 8;
  DISTINCT_GROUP_BY = 9;
  SELECTION = 10;
  JOIN = 11;
  UNION = 12;
  INTERSECT = 13;
  EXCEPT = 14;
  TABLE_SUBQUERY = 15;
  SCAN = 16;
  PARTITIONS_SCAN = 17;
  BST_INDEX_SCAN = 18;
  STORE = 19;
  INSERT = 20;

  CREATE_DATABASE = 21;
  DROP_DATABASE = 22;
  CREATE_TABLE = 23;
  DROP_TABLE = 24;
  ALTER_TABLESPACE = 25;
  ALTER_TABLE = 26;
  TRUNCATE_TABLE = 27;
}

message LogicalNodeTree {
  repeated LogicalNode nodes = 1;
}

message LogicalNode {
  required int32 visit_seq = 1;
  required int32 node_id = 2;
  required NodeType type = 3;
  optional SchemaProto in_schema = 4;
  optional SchemaProto out_schema = 5;

  optional ScanNode scan = 6;
  optional PartitionScanSpec partition_scan = 7;
  optional JoinNode join = 8;
  optional FilterNode filter = 9;
  optional GroupbyNode groupby = 10;
  optional DistinctGroupbyNode distinct_groupby = 11;
  optional SortNode sort = 12;
  optional LimitNode limit = 13;
  optional WindowAggNode window_agg = 14;
  optional ProjectionNode projection = 15;
  optional EvalExprNode expr_eval = 16;
  optional UnionNode union = 17;
  optional TableSubQueryNode table_sub_query = 18;
  optional PersistentStoreNode persistent_store = 19;
  optional StoreTableNodeSpec store_table = 20;
  optional InsertNodeSpec insert = 21;
  optional CreateTableNodeSpec create_table = 22;
  optional RootNode root = 23;
  optional SetSessionNode set_session = 24;

  optional CreateDatabaseNode create_database = 25;
  optional DropDatabaseNode drop_database = 26;
  optional DropTableNode drop_table = 27;

  optional AlterTablespaceNode alter_tablespace = 28;
  optional AlterTableNode alter_table = 29;
  optional TruncateTableNode truncate_table_node = 30;
}

message ScanNode {
  required TableDescProto table = 1;
  optional string alias = 2;
  required bool exist_targets = 3;
  repeated Target targets = 4;
  optional EvalNodeTree qual = 5;
  optional bool broadcast = 6;
}

message PartitionScanSpec {
  repeated string paths = 1;
}

message FilterNode {
  required int32 child_seq = 1;
  required EvalNodeTree qual = 2;
}

message JoinNode {
  required int32 left_child_seq = 1;
  required int32 right_chil_seq = 2;
  required JoinType join_type = 3;
  optional EvalNodeTree join_qual = 4;
  required bool exists_targets = 5;
  repeated Target targets = 6;
}

message GroupbyNode {
  required int32 child_seq = 1;
  required bool distinct = 2;
  repeated ColumnProto grouping_keys = 3;
  repeated EvalNodeTree agg_functions = 4;
  repeated Target targets = 5;
}

message DistinctGroupbyNode {
  required int32 child_seq = 1;
  optional LogicalNode groupby_node = 2;
  repeated LogicalNode sub_plans = 3;
  repeated Target targets = 4;
  repeated ColumnProto grouping_keys = 5;
  repeated int32 result_id = 6;
  repeated EvalNodeTree agg_functions = 7;
}

message SortNode {
  required int32 child_seq = 1;
  repeated SortSpecProto sort_specs = 2;
}

message LimitNode {
  required int32 child_seq = 1;
  required int64 fetch_first_num = 2;
}

message WindowAggNode {
  required int32 child_seq = 1;
  repeated ColumnProto partition_keys = 2;
  repeated SortSpecProto sort_specs = 3;
  repeated EvalNodeTree window_functions = 4;
  // If distinct aggregation function is included in window function
  required bool distinct = 5;
  repeated Target targets = 6;
}

message UnionNode {
  required int32 left_child_seq = 1;
  required int32 right_child_seq = 2;
  required bool all = 3;
}

message TableSubQueryNode {
  required int32 child_seq = 1;
  required string table_name = 2;
  repeated Target targets = 3;
}

message ProjectionNode {
  required int32 child_seq = 1;
  required bool distinct = 2;
  repeated Target targets = 3;
}

message EvalExprNode {
  repeated Target targets = 1;
}

message RootNode {
  required int32 child_seq = 1;
}

message SetSessionNode {
  required string name = 1;
  optional string value = 2;
}

message Target {
  required EvalNodeTree expr = 1;
  optional string alias = 2;
}

enum JoinType {
  CROSS_JOIN = 0;
  INNER_JOIN = 1;
  LEFT_OUTER_JOIN = 2;
  RIGHT_OUTER_JOIN = 3;
  FULL_OUTER_JOIN = 4;
  UNION_JOIN = 5;
  LEFT_ANTI_JOIN = 6;
  RIGHT_ANTI_JOIN = 7;
  LEFT_SEMI_JOIN = 8;
  RIGHT_SEMI_JOIN = 9;
}

message PartitionTableScanSpec {
  repeated string paths = 1;
}

message PersistentStoreNode {
  required int32 child_seq = 1;
  required StoreType storage_type = 2;
  required KeyValueSetProto table_properties = 3;
}

message StoreTableNodeSpec {  // required PersistentStoreSpec
  optional string table_name = 1;  // 'INSERT INTO LOCATION' does not require 'table name'.
  optional PartitionMethodProto partition_method = 2;
}

message InsertNodeSpec {  // required PersistentStoreSpec and StoreTableSpec
  required bool overwrite = 1;
  required SchemaProto table_schema = 2;
  optional SchemaProto target_schema = 4;
  optional SchemaProto projected_schema = 3;
  optional string path = 5;
}

message CreateTableNodeSpec {  // required PersistentStoreSpec and StoreTableNodeSpec
  required SchemaProto schema = 1;
  required bool external = 2;
  required bool if_not_exists = 3;
  optional string path = 4;
}

message DropTableNode {
  required string table_name = 1;
  required bool if_exists = 2;
  required bool purge = 3;
}

message TruncateTableNode {
  repeated string table_names = 1;
}

message CreateDatabaseNode {
  required string db_name = 1;
  required bool if_not_exists = 2;
}

message DropDatabaseNode {
  required string db_name = 1;
  required bool if_exists = 2;
}

message AlterTablespaceNode {
  enum Type {
    LOCATION = 0;
  }

  message SetLocation {
    required string location = 1;
  }

  required string table_space_name = 1;
  required Type set_type = 2;
  optional SetLocation set_location = 3;
}

message AlterTableNode {
  enum Type {
    RENAME_TABLE = 0;
    RENAME_COLUMN = 1;
    ADD_COLUMN = 2;
  }

  message RenameTable {
    required string new_name = 1;
  }

  message RenameColumn {
    required string old_name = 1;
    required string new_name = 2;
  }

  message AddColumn {
    required ColumnProto add_column = 1;
  }

  required string table_name = 1;
  required Type set_type = 2;
  optional RenameTable rename_table = 3;
  optional RenameColumn rename_column = 4;
  optional AddColumn add_column = 5;
}

enum EvalType {
  NOT = 0;
  AND = 1;
  OR = 2;
  EQUAL = 3;
  IS_NULL = 4;
  NOT_EQUAL = 5;
  LTH = 6;
  LEQ = 7;
  GTH = 8;
  GEQ = 9;
  PLUS = 10;
  MINUS = 11;
  MODULAR = 12;
  MULTIPLY = 13;
  DIVIDE = 14;

  // Binary Bitwise expressions
  BIT_AND = 15;
  BIT_OR = 16;
  BIT_XOR = 17;

  // Function
  WINDOW_FUNCTION = 18;
  AGG_FUNCTION = 19;
  FUNCTION = 20;

  // String operator or pattern matching predicates
  LIKE = 21;
  SIMILAR_TO = 22;
  REGEX = 23;
  CONCATENATE = 24;

  // Other predicates
  BETWEEN = 25;
  CASE = 26;
  IF_THEN = 27;
  IN = 28;

  // Value or Reference
  SIGNED = 29;
  CAST = 30;
  ROW_CONSTANT = 31;
  FIELD = 32;
  CONST = 33;
}

message EvalNodeTree {
  repeated EvalNode nodes = 1;
}

message EvalNode {
  required int32 id = 1;
  required EvalType type = 2;
  required DataType data_type = 3;

  optional UnaryEval unary = 4; // NOT
  optional BinaryEval binary = 5;
  optional ConstEval const = 6;
  optional ColumnProto field = 7; // field eval
  optional FunctionEval function = 8;
  optional AggFunctionEvalSpec agg_function = 9;
  optional WinFunctionEvalSpec win_function = 10;
  optional RowConstEval row_const = 11;
  optional BetweenEval between = 12;
  optional CaseWhenEval casewhen = 13;
  optional IfCondEval if_cond = 14;
  optional PatternMatchEvalSpec pattern_match = 15;
}

message UnaryEval {
  required int32 child_id = 1;
  optional DataType casting_type = 2;
  optional bool negative = 3;
  optional string timezone = 4;
}

message BinaryEval {
  required int32 lhs_id = 1;
  required int32 rhs_id = 2;
  optional bool negative = 3 [default = false];
}

message PatternMatchEvalSpec { // requires BinaryEval
  optional bool case_sensitive = 1;
}

message BetweenEval {
  required int32 predicand = 1;
  required int32 begin = 2;
  required int32 end = 3;
  optional bool negative = 4 [default = false];
  optional bool symmetric = 5 [default = false];
}

message CaseWhenEval {
  repeated int32 if_conds = 1;
  optional int32 else = 2;
}

message IfCondEval {
  required int32 condition = 1;
  required int32 then = 2;
}

message ConstEval {
  required Datum value = 1;
}

message RowConstEval {
  repeated Datum values = 1;
}

message FunctionEval {
  required FunctionDescProto function = 1;
  repeated int32 param_ids = 2;
}

message AggFunctionEvalSpec {  // requires FunctionEval
  required bool intermediate_phase = 1;
  required bool final_phase = 2;
  optional string alias = 3;
}

message WinFunctionEvalSpec {
  message WindowFrame {
    required WindowStartBound start_bound = 1;
    required WindowEndBound end_bound = 2;
    optional WindowFrameUnit unit = 3;
  }

  enum WindowFrameStartBoundType {
    S_UNBOUNDED_PRECEDING = 0;
    S_CURRENT_ROW = 1;
    S_PRECEDING = 2;
  }

  enum WindowFrameEndBoundType {
    E_UNBOUNDED_FOLLOWING = 0;
    E_CURRENT_ROW = 1;
    E_FOLLOWING = 2;
  }

  enum WindowFrameUnit {
    ROW = 0;
    RANGE = 1;
  }

  message WindowStartBound {
    required WindowFrameStartBoundType bound_type = 1;
    optional EvalNodeTree number = 2;
  }

  message WindowEndBound {
    required WindowFrameEndBoundType bound_type = 1;
    optional EvalNodeTree number = 2;
  }

  repeated SortSpecProto sort_spec = 1;
  required WindowFrame window_frame = 2;
}

message Datum {
  required Type type = 1;
  optional bool boolean = 2;
  optional int32 int4 = 3;    // int4, date
  optional int64 int8 = 4;    // int8, timestamp, and time
  optional float float4 = 5;
  optional double float8 = 6;
  optional string text = 7;
  optional bytes blob = 8;
  optional Interval interval = 12;
}

message Interval {
  optional int32 month = 1 [default = 0];
  optional int64 msec = 2;
}

enum ShuffleType {
  NONE_SHUFFLE = 0;
  HASH_SHUFFLE = 1;
  RANGE_SHUFFLE = 2;
  SCATTERED_HASH_SHUFFLE = 3;
}

enum TransmitType {
  PUSH_TRANSMIT = 0;
  PULL_TRANSMIT = 1;
  FILE_WRITE = 2;
}
